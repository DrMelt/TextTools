#target 'InDesign'//########################//選択された文字をルビにします。//誕生日(たんじょうび)//を選択すると誕生日にグループルビが付きます。//誕生日(たん.じょう.び)//を選択すると誕生日にモノルビが付きます。//たけうちとおる//########################var myDocu=app.activeDocument;var selList = SelectClean(myDocu.selection); // 選択範囲を整理してから処理に入れるvar itemCount=selList.length;var errorCount = 0;var totalStrCount = 0;if(itemCount==0){	alert("処理したいテキストフレームなどを\n選択ツールで選択して実行してください。");}for(var item_index=itemCount-1; item_index > -1; item_index--){//選択オブジェクト分逆順で繰り返す。エラー処理なし	var c_name = selList[item_index].constructor.name;	//変数初期化    var myChaFlg = "";    var myOyaFlg = "";    var myRubyFlg = 0;	if(c_name == "TextFrame" && selList[item_index].overflows == true){selList[item_index] = selList[item_index].parentStory;}	var mySelLength = selList[item_index].characters.length;	totalStrCount = totalStrCount + mySelLength;//ここで総文字量を数えておく	for(var c = mySelLength-1;c > -1; c--){//選択された文字列を後ろからループしていく		try{			var myCha = selList[item_index].characters[c].contents;		}catch(e){myChaFlg = "ELSE";}        try{		if(myCha == ")" && myRubyFlg != 2){//")"ならルビ文字の最後            var myRubyEndCha = c;            myRubyFlg = 1;            myChaFlg = "ELSE";        }else if(myCha == "(" && myRubyFlg == 1){//"("ならルビ文字の最初            var myRubyStartCha = c;            myRubyFlg = 2;            var myOyaRubyCount = 0;        }else if(myCha.match (/(?:[々〇〻\u3400-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF])/) && myRubyFlg == 2){//ものかの ‏@monokanoさん記述            //漢字だったら            myChaFlg = "KANJI";//今の文字の種類            if(myOyaRubyCount == 0){myOyaFlg = "KANJI";}//最初の親文字の種類をmyOyaFlgに入れておく         }else if(myCha.match (/[ァ-ヺー-ヿㇰ-ㇿ]/) && myRubyFlg == 2){//ものかの ‏@monokanoさん記述             //カタカナだったら            myChaFlg = "KATAKANA";            if(myOyaRubyCount == 0){myOyaFlg = "KATAKANA";}         }else if(myCha.match (/[ぁ-ゖゝ-ゟー]/) && myRubyFlg == 2){//ものかの ‏@monokanoさん記述             //ひらがなだったら            myChaFlg = "HIRAGANA";            if(myOyaRubyCount == 0){myOyaFlg = "HIRAGANA";}         }else if(myCha.match (/[a-zA-Z0-9]/) && myRubyFlg == 2){             //アルファベットだったら            myChaFlg = "ALPHA";            if(myOyaRubyCount == 0){myOyaFlg = "ALPHA";}        }else{			//それ以外            myChaFlg = "ELSE";        }		}catch(e){myChaFlg = "ELSE";}        if(myChaFlg == myOyaFlg){myOyaRubyCount++;}//最初の親文字の種類と同じならmyOyaRubyCountを増やしていく		if(c == 0){myChaFlg = "TOP";}//先頭まで来た        if(myChaFlg != myOyaFlg && myOyaRubyCount > 0){//最初の親文字と今の文字の種類が変わったらルビ処理			setRuby(selList[item_index],myRubyStartCha - myOyaRubyCount, myRubyStartCha-1,myRubyStartCha+1, myRubyEndCha-1,c_name);                myChaFlg = "";                myOyaFlg = "";                myRubyFlg = 0;                myOyaRubyCount = 0;                c++;		}	//範囲選択の場合ルビ処理をした後カッコ文字を削除するので再度選択範囲を取得する。         if(c_name != "TextFrame" && c_name != "Cell" && c_name != "Table"){selList=myDocu.selection;}	}}if(errorCount > 0){	alert("ルビに出来なかった部分が"+errorCount+"ヶ所あります。もとのテキストのまま残しています。");}else if(totalStrCount > 1000){	alert("終了しました。");}function setRuby(selList,myOyaRubyStartCha,myOyaRubyEndCha,myRubyStartCha,myRubyEndCha,c_name){    var kanji = selList.characters.itemByRange(myOyaRubyStartCha, myOyaRubyEndCha).contents[0];    var kana = selList.characters.itemByRange(myRubyStartCha, myRubyEndCha).contents[0];    var kanaAry = kana.split(".");    var rubyCount = kanaAry.length;    if(rubyCount == 1){		//グループルビ        selList.characters.itemByRange(myOyaRubyStartCha, myOyaRubyEndCha).rubyString = kana;        selList.characters.itemByRange(myOyaRubyStartCha, myOyaRubyEndCha).rubyType = RubyTypes.GROUP_RUBY;        selList.characters.itemByRange(myOyaRubyStartCha, myOyaRubyEndCha).rubyFlag = true;        selList.characters.itemByRange(myRubyStartCha-1, myRubyEndCha+1).contents = "";    }else if(rubyCount > 1){		//モノルビ		//ものかのさんのアドバイスにより改訂親字がサロゲートペアのときのため		kanji = kanji.replace(/(?:[\uD840-\uD87F][\uDC00-\uDFFF])/g,"漢"); //「漢」はダミー文字		var kanjiCount = kanji.length;		//親文字とルビ文字の数が不一致の場合なにもしない。		if(kanjiCount != rubyCount){errorCount++;return;}		for(var i = 0; i < kanjiCount;i++){			selList.characters[myOyaRubyStartCha+i].rubyString = kanaAry[i];			selList.characters[myOyaRubyStartCha+i].rubyFlag = true;		}		selList.characters.itemByRange(myRubyStartCha-1, myRubyEndCha+1).contents = "";	}}function SelectClean(sc){	//流星光輝 ‏@ryusei3000さん修正    // 選択範囲を、なるべく綺麗にゴシゴシ洗浄    var arr=[];    for(si=0; si<sc.length; si++){        var scnm=sc[si].constructor.name;            if(scnm.match(/Rectangle|Oval|Polygon|GraphicLine/)){                // 基本的に処理できないはずだけど、パステキストの時は処理対象に含める                for(sj=0; sj<sc[si].textPaths.length; sj++){                    arr.push(sc[si].textPaths[sj].parentStory);                    }            } else if (scnm.match(/Table|Cell/)) {                // 表内のセル内の文字を選択範囲とする                for(sj=0; sj<sc[si].cells.length; sj++){                    arr.push(sc[si].cells[sj]);//ちょっと修正                    }            } else if (scnm.match(/Group/)) {                // Group内のTextFrameがあれば対象にする                if (sc[si].textFrames.length != 0){                    for(sj=0; sj<sc[si].textFrames.length; sj++) {                        arr.push(sc[si].textFrames[sj]);                        }                    }            }else{                // TextFrame|InsertionPoint|Character|Text|Paragraph|Line|TextStyleRange|Word|TextColumn                arr.push(sc[si]); // 処理範囲に追加                }         }    return arr;    }